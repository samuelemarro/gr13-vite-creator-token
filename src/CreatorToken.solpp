// SPDX-License-Identifier: MIT
/// @title Creator Token implementation for GR13 Hackathon
/// @author Samuele Marro
/// @notice Uses linear bonding curves.

pragma soliditypp ^0.8.0;

contract CreatorToken {
    // We use uint128 so that squares don't overflow in uint256 math
    mapping(address => uint128) public supplies;
    mapping(address => uint128) public coefficients;
    // owner => (tokenId => amount) mapping
    mapping(address => mapping(address => uint128)) public balances;

    uint128 public constant MINIMUM_SUPPLY = 1e5;

    constructor () {
    }

    function balanceOf(address owner, address tokenId) public view returns(uint128) {
        return balances[owner][tokenId];
    }

    function _tradableSupply(address tokenId) internal view returns(uint128) {
        return supplies[tokenId] - MINIMUM_SUPPLY;
    }

    function _tokenCoefficient(address tokenId) internal view returns(uint128) {
        return coefficients[tokenId];
    }

    function currentPrice(address _tokenId) external view returns(uint128) {
        return _tradableSupply(_tokenId) * _tokenCoefficient(_tokenId);
    }

    function transfer(address _to, address _tokenId, uint128 _amount) external {
        require(_to != address(this), "CreatorToken: cannot transfer to self");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount);
        balances[msg.sender][_tokenId] -= _amount;
        balances[_to][_tokenId] += _amount;
    }

    function mint(address _tokenId, uint128 _amount) external payable {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        
        uint256 computedMintCost = _mintCost(_tokenId, _amount);
        require(msg.value >= computedMintCost, "CreatorToken: not enough Vite to mint");

        supplies[_tokenId] += _amount;
        balances[msg.sender][_tokenId] += _amount;

        if (msg.value > computedMintCost) {
            // Minter overpaid, send back the difference
            uint256 refund = msg.value - computedMintCost;
            payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", refund);
        }
    }

    function burn(address _tokenId, uint128 _amount) external {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        require(balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");

        uint256 computedBurnRevenue = _burnRevenue(_tokenId, _amount);

        supplies[_tokenId] -= _amount;
        balances[msg.sender][_tokenId] -= _amount;

        payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", computedBurnRevenue);
    }

    function _computeIntegral(address _tokenId, uint128 _oldSupply, uint128 _newSupply) internal view returns(int256) {
        require(_oldSupply >= MINIMUM_SUPPLY);
        require(_newSupply >= MINIMUM_SUPPLY);
        int256 tradableOldSupply = int256(uint256(_oldSupply - MINIMUM_SUPPLY));
        int256 tradableNewSupply = int256(uint256(_newSupply - MINIMUM_SUPPLY));

        // Integral of coefficient * tradableSupply is
        //  coefficient * x^2 / 2
        // Therefore \int_old^new (coefficient * x) dx =
        //   coefficient * (new^2 - old^2) / 2
        // Note: the division does not require rounding because the coefficient
        // is always even
        return int256(uint256(coefficients[_tokenId])) * (
            tradableNewSupply * tradableNewSupply - tradableOldSupply * tradableOldSupply
        ) / 2;
    }

    function _mintCost(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        return uint256(_computeIntegral(_tokenId, oldSupply, oldSupply + _amount));
    }

    function mintCost(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0);
        return _mintCost(_tokenId, _amount);
    }

    function _burnRevenue(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        return uint256(-_computeIntegral(_tokenId, oldSupply, oldSupply - _amount));
    }

    function burnRevenue(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");
        return _burnRevenue(_tokenId, _amount);
    }

    function createToken(uint128 coefficient) public {
        require(supplies[msg.sender] == 0, "CreatorToken: token already created");
        require(coefficient % 2 == 0, "CreatorToken: coefficient must be even");
        supplies[msg.sender] = MINIMUM_SUPPLY;
        balances[msg.sender][msg.sender] = MINIMUM_SUPPLY;
        coefficients[msg.sender] = coefficient;
    }
}