// SPDX-License-Identifier: MIT
/// @title Creator Token implementation for GR13 Hackathon
/// @author Samuele Marro
/// @notice Uses linear bonding curves.

pragma soliditypp ^0.8.0;

contract CreatorToken {
    // We use uint128 so that squares don't overflow in uint256 math
    mapping(address => uint128) private supplies;
    mapping(address => uint128) private coefficients;
    // owner => (tokenId => amount) mapping
    mapping(address => mapping(address => uint128)) private balances;

    // Note: must be greater than 0
    uint128 public constant MINIMUM_SUPPLY = 1e4;

    constructor () {
    }

    // ===Getters===

    function exists(address _tokenId) public view returns (bool) {
        return supplies[_tokenId] > 0;
    }

    function _balanceOf(address _owner, address _tokenId) public view returns (uint128) {
        return balances[_owner][_tokenId];
    }

    function balanceOf(address _tokenId, address _owner) public view returns(uint128) {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        return balances[_owner][_tokenId];
    }

    function _totalSupply(address _tokenId) internal view returns(uint128) {
        return supplies[_tokenId];
    }

    function totalSupply(address _tokenId) external view returns(uint128) {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        return _totalSupply(_tokenId);
    }

    function _tradableSupply(address _tokenId) internal view returns(uint128) {
        return supplies[_tokenId] - MINIMUM_SUPPLY;
    }

    function tradableSupply(address _tokenId) external view returns(uint128) {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        return _tradableSupply(_tokenId);
    }

    function _tokenCoefficient(address tokenId) internal view returns(uint128) {
        return coefficients[tokenId];
    }

    function tokenCoefficient(address tokenId) external view returns(uint128) {
        require(exists(tokenId), "CreatorToken: token does not exist");
        return _tokenCoefficient(tokenId);
    }

    function currentPrice(address _tokenId) external view returns(uint128) {
        return _tradableSupply(_tokenId) * _tokenCoefficient(_tokenId);
    }

    // ===Non-Sale Methods===

    function createToken(uint128 coefficient) public {
        require(supplies[msg.sender] == 0, "CreatorToken: token already created");
        require(coefficient % 2 == 0, "CreatorToken: coefficient must be even");
        supplies[msg.sender] = MINIMUM_SUPPLY;
        balances[msg.sender][msg.sender] = MINIMUM_SUPPLY;
        coefficients[msg.sender] = coefficient;
    }

    function transfer(address _to, address _tokenId, uint128 _amount) external {
        require(_to != address(this), "CreatorToken: cannot transfer to self");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount);
        balances[msg.sender][_tokenId] -= _amount;
        balances[_to][_tokenId] += _amount;
    }

    // ===Sale Methods===

    function _computeIntegral(address _tokenId, uint128 _oldSupply, uint128 _newSupply) internal view returns(int256) {
        int256 tradableOldSupply = int256(uint256(_oldSupply - MINIMUM_SUPPLY));
        int256 tradableNewSupply = int256(uint256(_newSupply - MINIMUM_SUPPLY));

        // Integral of coefficient * tradableSupply is
        //  coefficient * x^2 / 2
        // Therefore \int_old^new (coefficient * x) dx =
        //   coefficient * (new^2 - old^2) / 2
        // Note: the division does not require rounding because the coefficient
        // is always even
        return int256(uint256(_tokenCoefficient(_tokenId))) * (
            tradableNewSupply * tradableNewSupply - tradableOldSupply * tradableOldSupply
        ) / 2;
    }

    function _mintCost(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        return uint256(_computeIntegral(_tokenId, oldSupply, oldSupply + _amount));
    }

    function mintCost(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        require(_amount > 0, "CreatorToken: amount must be greater than 0");
        return _mintCost(_tokenId, _amount);
    }

    function mint(address _tokenId, uint128 _amount) external payable {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        
        uint256 computedMintCost = _mintCost(_tokenId, _amount);
        require(msg.value >= computedMintCost, "CreatorToken: not enough Vite to mint");

        supplies[_tokenId] += _amount;
        balances[msg.sender][_tokenId] += _amount;

        if (msg.value > computedMintCost) {
            // Minter overpaid (e.g. to avoid frontrunning), send back the difference
            uint256 refund = msg.value - computedMintCost;
            payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", refund);
        }
    }

    function _burnRevenue(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = _totalSupply(_tokenId);

        return uint256(-_computeIntegral(_tokenId, oldSupply, oldSupply - _amount));
    }

    function burnRevenue(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        require(_balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");
        return _burnRevenue(_tokenId, _amount);
    }

    function burn(address _tokenId, uint128 _amount) external {
        require(exists(_tokenId), "CreatorToken: token does not exist");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        require(_balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");

        uint256 computedBurnRevenue = _burnRevenue(_tokenId, _amount);

        supplies[_tokenId] -= _amount;
        balances[msg.sender][_tokenId] -= _amount;

        payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", computedBurnRevenue);
    }
}