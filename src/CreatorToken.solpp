// SPDX-License-Identifier: MIT
/// @title Creator Token implementation for GR13 Hackathon
/// @author Samuele Marro
/// @notice Uses linear bonding curves.

pragma soliditypp ^0.8.0;

contract CreatorToken {
    // We use uint128 so that squares don't overflow in uint256 math
    mapping(address => uint128) public supplies;
    mapping(address => uint128) public coefficients;
    // owner => (tokenId => amount) mapping
    mapping(address => mapping(address => uint128)) public balances;
    mapping(address => uint256) public backingBalances;

    uint128 public constant TOKEN_PRECISION = 1e18;
    uint128 public constant SQUARED_TOKEN_PRECISION = TOKEN_PRECISION * TOKEN_PRECISION;
    uint128 public constant MINIMUM_SUPPLY = TOKEN_PRECISION * 1e5;
    uint128 public constant COEFFICIENT_PRECISION = 1e5;

    constructor () {
    }

    function balanceOf(address owner, address tokenId) public view returns(uint128) {
        return balances[owner][tokenId];
    }

    function _tradableSupply(address tokenId) internal view returns(uint128) {
        return supplies[tokenId] - MINIMUM_SUPPLY;
    }

    function _tokenCoefficient(address tokenId) internal view returns(uint128) {
        return coefficients[tokenId];
    }

    function currentPrice(address _tokenId) external view returns(uint128) {
        return _tradableSupply(_tokenId) * _tokenCoefficient(_tokenId) / COEFFICIENT_PRECISION;
    }

    function transfer(address _to, address _tokenId, uint128 _amount) external {
        require(_to != address(this), "CreatorToken: cannot transfer to self");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount);
        balances[msg.sender][_tokenId] -= _amount;
        balances[_to][_tokenId] += _amount;
    }

    function mint(address _tokenId, uint128 _amount) external payable {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        
        uint256 computedMintCost = _mintCost(_tokenId, _amount);
        require(msg.value >= computedMintCost, "CreatorToken: not enough Vite to mint");

        supplies[_tokenId] += _amount;
        balances[msg.sender][_tokenId] += _amount;
        backingBalances[_tokenId] += computedMintCost;

        if (msg.value > computedMintCost) {
            // Minter overpaid, send back the difference
            uint256 refund = msg.value - computedMintCost;
            payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", refund);
        }
    }

    function burn(address _tokenId, uint128 _amount, uint256 _absoluteTolerance) external {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        require(balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");

        uint256 computedBurnRevenue = _burnRevenue(_tokenId, _amount);

        uint256 availableBackingBalance = backingBalances[_tokenId];
        uint256 actualBurnRevenue;

        // actualBurnRevenue = min(availableBackingBalance, computedBurnRevenue)
        if (availableBackingBalance >= computedBurnRevenue) {
            actualBurnRevenue = computedBurnRevenue;
        } else {
            actualBurnRevenue = availableBackingBalance;
        }

        if (actualBurnRevenue > computedBurnRevenue + _absoluteTolerance) {
            // Contract does not have enough backing to cover the burn (e.g. due to rounding)
            revert("CreatorToken: not enough backing to cover burn");
        }

        supplies[_tokenId] -= _amount;
        balances[msg.sender][_tokenId] -= _amount;
        backingBalances[_tokenId] -= actualBurnRevenue;

        payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", actualBurnRevenue); // TODO: Fix
    }

    function _computeIntegral(address _tokenId, uint128 _oldSupply, uint128 _newSupply) internal view returns(uint256) {
        require(_oldSupply >= MINIMUM_SUPPLY);
        require(_newSupply >= MINIMUM_SUPPLY);
        uint256 tradableOldSupply = uint256(_oldSupply - MINIMUM_SUPPLY);
        uint256 tradableNewSupply = uint256(_newSupply - MINIMUM_SUPPLY);

        // Integral of coefficient * tradableSupply is
        // coefficient * (tradableSupply^2) / 2
        // We rearrange it to mitigate overflows and underflows
        return coefficients[_tokenId] * (
            (tradableNewSupply * tradableNewSupply - tradableOldSupply * tradableOldSupply) / SQUARED_TOKEN_PRECISION
        ) / (2 * COEFFICIENT_PRECISION);
    }

    function _mintCost(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        // Negative of integral from a to b = integral from b to a
        return uint256(_computeIntegral(_tokenId, oldSupply + _amount, oldSupply));
    }

    function mintCost(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0);
        return _mintCost(_tokenId, _amount);
    }

    function _burnRevenue(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        return uint256(_computeIntegral(_tokenId, oldSupply, oldSupply - _amount));
    }

    function burnRevenue(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");
        return _burnRevenue(_tokenId, _amount);
    }

    function createToken() public {
        require(supplies[msg.sender] == 0, "CreatorToken: token already created");
        supplies[msg.sender] = MINIMUM_SUPPLY;
        balances[msg.sender][msg.sender] = MINIMUM_SUPPLY;
    }
}