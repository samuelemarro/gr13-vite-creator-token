// SPDX-License-Identifier: MIT
/// @title Indexed Mapping
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

import "./PriorityQueue.solpp";

contract IndexedMapping {
    using PriorityQueue for *;

    struct HolderInfo {
        address holder;
        uint256 balance;
    }

    mapping(uint256 => HolderInfo) internal holderInfos;
    mapping(address => uint256) internal addressToId;
    uint256 length = 1; // start at 1, since 0 is reserved for empty key

    function exists(address _address) public view returns (bool) {
        return addressToId[_address] != 0;
    }

    function insert(address _address, uint256 _balance) public {
        if (exists(_address)) {
            holderInfos[addressToId[_address]].balance = _balance;
        }
        else {
            holderInfos[length] = HolderInfo(_address, _balance);
            addressToId[_address] = length;
            length++;
        }
    }

    function get(address _address) public view returns (uint256) {
        return holderInfos[addressToId[_address]].balance;
    }

    function topKs(uint256 k) public view returns (address[] memory) {
        PriorityQueue.Queue memory queue;

        for (uint256 i = 1; i < length + 1; i++) {
            if (holderInfos[i].balance != 0) {
                queue.push(PriorityQueue.Pair(holderInfos[i].balance, holderInfos[i].holder));
                if (queue.size() > k) {
                    // Pop the lowest value
                    queue.pop();
                }
            }
        }

        uint256 size = queue.size();
        address[] memory topK = new address[](size);

        for (uint256 i = 0; i < size; i++) {
            // Popping returns the lowest value
            topK[k - i] = queue.pop().data;
        }

        return topK;
    }
}