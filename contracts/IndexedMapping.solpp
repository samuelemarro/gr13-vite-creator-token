// SPDX-License-Identifier: MIT
/// @title Indexed Mapping
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

import "./PriorityQueue.solpp";

library IndexedMapping {
    using PriorityQueue for *;

    struct HolderInfo {
        address holder;
        uint256 balance;
    }

    struct Map {
        mapping(uint256 => HolderInfo) holderInfos;
        mapping(address => uint256) addressToId;
        uint256 length;
    }

    function exists(Map storage self, address _address) internal view returns (bool) {
        return self.addressToId[_address] != 0;
    }

    function set(Map storage self, address _address, uint256 _balance) internal {
        if (exists(self, _address)) {
            self.holderInfos[self.addressToId[_address]].balance = _balance;
        }
        else {
            uint256 id = self.length + 1; // ID 0 is reserved for the null element
            self.holderInfos[id] = HolderInfo(_address, _balance);
            self.addressToId[_address] = id;
            self.length++;
        }
    }

    function get(Map storage self, address _address) internal view returns (uint256) {
        return self.holderInfos[self.addressToId[_address]].balance;
    }

    function topKs(Map storage self, uint256 k) internal view returns (address[] memory) {
        PriorityQueue.Queue memory queue = PriorityQueue.newQueue(k);

        for (uint256 i = 1; i < self.length + 1; i++) {
            if (self.holderInfos[i].balance != 0) {
                queue.push(PriorityQueue.Pair(self.holderInfos[i].balance, self.holderInfos[i].holder));
                if (queue.size() > k) {
                    // Pop the lowest value
                    queue.pop();
                }
            }
        }

        uint256 size = queue.size();
        address[] memory topK = new address[](size);

        for (uint256 i = 0; i < size; i++) {
            // Popping returns the lowest value
            topK[k - i] = queue.pop().data;
        }

        return topK;
    }
}