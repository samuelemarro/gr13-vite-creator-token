// SPDX-License-Identifier: MIT
/// @title Creator Token implementation for GR13 Hackathon
/// @author Samuele Marro
/// @notice Uses linear bonding curves. We use the inverse integral in order to prevent front-running and race conditions.

pragma soliditypp ^0.8.0;

contract CreatorToken {
    // We use uint128 so that squares don't overflow in uint256 math
    mapping(address => uint128) public supplies;
    mapping(address => uint128) public coefficients;
    // owner => (tokenId => amount) mapping
    mapping(address => mapping(address => uint128)) public balances;
    mapping(address => uint256) public backingBalances;

    uint128 public constant TOKEN_PRECISION = 1e18;
    uint128 public constant SQUARED_TOKEN_PRECISION = TOKEN_PRECISION * TOKEN_PRECISION;
    uint128 public constant MINIMUM_SUPPLY = TOKEN_PRECISION * 1e5;
    uint128 public constant COEFFICIENT_PRECISION = 1e5;

    constructor () {
    }

    function balanceOf(address owner, address tokenId) public view returns(uint128) {
        return balances[owner][tokenId];
    }

    function _tradableSupply(address tokenId) internal view returns(uint128) {
        return supplies[tokenId] - MINIMUM_SUPPLY;
    }

    function _tokenCoefficient(address tokenId) internal view returns(uint128) {
        return coefficients[tokenId];
    }

    function currentPrice(address _tokenId) external view returns(uint128) {
        return _tradableSupply(_tokenId) * _tokenCoefficient(_tokenId) / COEFFICIENT_PRECISION;
    }

    function transfer(address _to, address _tokenId, uint128 _amount) external {
        require(_to != address(this), "CreatorToken: cannot transfer to self");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount);
        balances[msg.sender][_tokenId] -= _amount;
        balances[_to][_tokenId] += _amount;
    }

    function _inverseIntegral(address _tokenId, uint128 _oldSupply, uint256 _difference) internal view returns(uint128) {
        require(_oldSupply >= MINIMUM_SUPPLY);
    
        uint256 tradableOldSupply = uint256(_oldSupply - MINIMUM_SUPPLY);

        // Integral of coefficient * tradableSupply is
        //  coefficient * (tradableSupply^2) / 2
        // Therefore
        //  difference = coefficient/2 * new^2 - coefficient/2 * old^2
        // Rearranging, we get 
        //  2/coefficient * difference = new^2 - old^2
        // which is equivalent to
        //  new = sqrt(2/coefficient * difference - old^2)
        uint256 newSupply = _sqrt((2 * _difference * COEFFICIENT_PRECISION / coefficients[_tokenId]) - (tradableOldSupply * tradableOldSupply) / (TOKEN_PRECISION * TOKEN_PRECISION));
        return uint128(newSupply + MINIMUM_SUPPLY);
    }

    function mint(address _tokenId, uint128 _amount) external payable {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        
        uint256 computedMintCost = _mintCost(_tokenId, _amount);
        require(msg.value >= computedMintCost, "CreatorToken: not enough Vite to mint");

        supplies[_tokenId] += _amount;
        balances[msg.sender][_tokenId] += _amount;
        backingBalances[_tokenId] += computedMintCost;

        if (msg.value > computedMintCost) {
            // Minter overpaid, send back the difference
            uint256 refund = msg.value - computedMintCost;
            payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", refund);
        }
    }

    function burn(address _tokenId, uint128 _amount, uint256 _absoluteTolerance) external {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0, "CreatorToken: _amount must be greater than zero");
        require(balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");

        uint256 computedBurnRevenue = _burnRevenue(_tokenId, _amount);

        uint256 availableBackingBalance = backingBalances[_tokenId];
        uint256 actualBurnRevenue;

        // actualBurnRevenue = min(availableBackingBalance, computedBurnRevenue)
        if (availableBackingBalance >= computedBurnRevenue) {
            actualBurnRevenue = computedBurnRevenue;
        } else {
            actualBurnRevenue = availableBackingBalance;
        }

        if (actualBurnRevenue > computedBurnRevenue + _absoluteTolerance) {
            // Contract does not have enough backing to cover the burn (e.g. due to rounding)
            revert("CreatorToken: not enough backing to cover burn");
        }

        supplies[_tokenId] -= _amount;
        balances[msg.sender][_tokenId] -= _amount;
        backingBalances[_tokenId] -= actualBurnRevenue;

        payable(msg.sender).transfer("tti_5649544520544f4b454e6e40", actualBurnRevenue); // TODO: Fix
    }

    function _computeIntegral(address _tokenId, uint128 _oldSupply, uint128 _newSupply) internal view returns(uint256) {
        require(_oldSupply >= MINIMUM_SUPPLY);
        require(_newSupply >= MINIMUM_SUPPLY);
        uint256 tradableOldSupply = uint256(_oldSupply - MINIMUM_SUPPLY);
        uint256 tradableNewSupply = uint256(_newSupply - MINIMUM_SUPPLY);

        // Integral of coefficient * tradableSupply is
        // coefficient * (tradableSupply^2) / 2
        // We rearrange it to mitigate overflows and underflows
        return coefficients[_tokenId] * (
            (tradableNewSupply * tradableNewSupply - tradableOldSupply * tradableOldSupply) / SQUARED_TOKEN_PRECISION
        ) / (2 * COEFFICIENT_PRECISION);
    }

    function _mintCost(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        //-integral from a to b = integral from b to a
        return uint256(_computeIntegral(_tokenId, oldSupply + _amount, oldSupply));
    }

    function mintCost(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0);
        return _mintCost(_tokenId, _amount);
    }

    function _burnRevenue(address _tokenId, uint128 _amount) internal view returns(uint256) {
        uint128 oldSupply = supplies[_tokenId];

        return uint256(_computeIntegral(_tokenId, oldSupply, oldSupply - _amount));
    }

    function burnRevenue(address _tokenId, uint128 _amount) external view returns(uint256) {
        require(supplies[_tokenId] > 0, "CreatorToken: token has not been created");
        require(_amount > 0);
        require(balanceOf(msg.sender, _tokenId) >= _amount, "CreatorToken: not enough tokens to burn");
        return _burnRevenue(_tokenId, _amount);
    }

    /// @notice Calculates the square root of x, rounding down.
    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.
    ///
    /// Caveats:
    /// - This function does not work with fixed-point numbers.
    ///
    /// @param x The uint256 number for which to calculate the square root.
    /// @return result The result as an uint256.
    function _sqrt(uint256 x) internal pure returns (uint256 result) {
        if (x == 0) {
            return 0;
        }

        // Calculate the square root of the perfect square of a power of two that is the closest to x.
        uint256 xAux = uint256(x);
        result = 1;
        if (xAux >= 0x100000000000000000000000000000000) {
            xAux >>= 128;
            result <<= 64;
        }
        if (xAux >= 0x10000000000000000) {
            xAux >>= 64;
            result <<= 32;
        }
        if (xAux >= 0x100000000) {
            xAux >>= 32;
            result <<= 16;
        }
        if (xAux >= 0x10000) {
            xAux >>= 16;
            result <<= 8;
        }
        if (xAux >= 0x100) {
            xAux >>= 8;
            result <<= 4;
        }
        if (xAux >= 0x10) {
            xAux >>= 4;
            result <<= 2;
        }
        if (xAux >= 0x8) {
            result <<= 1;
        }

        // The operations can never overflow because the result is max 2^127 when it enters this block.
        unchecked {
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1; // Seven iterations should be enough
            uint256 roundedDownResult = x / result;
            return result >= roundedDownResult ? roundedDownResult : result;
        }
    }

    function createToken() public {
        require(supplies[msg.sender] == 0, "CreatorToken: token already created");
        supplies[msg.sender] = MINIMUM_SUPPLY;
        balances[msg.sender][msg.sender] = MINIMUM_SUPPLY;
    }
}